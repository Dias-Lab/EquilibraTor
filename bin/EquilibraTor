#! bin/env/ python

import os
import re
import sys
import time
import logging
import argparse
import subprocess
import numpy as np
import equilibrator.flat
import matplotlib.pyplot as plt

## Constants
IONS_MDP = os.path.join(os.path.dirname(equilibrator.flat.__file__),'ions.mdp')
MINIM_MDP = os.path.join(os.path.dirname(equilibrator.flat.__file__),'minimization_stage.mdp')
NVT_MDP = os.path.join(os.path.dirname(equilibrator.flat.__file__),'nvt_stage.mdp')
NPT_MDP = os.path.join(os.path.dirname(equilibrator.flat.__file__),'npt_stage.mdp')
PRODUCTION_MDP = os.path.join(os.path.dirname(equilibrator.flat.__file__),'production_stage.mdp')

VERSION = 'v1.0.0'

DESCRIPTION = """
   ____          _ ___ __           ______        
  / __/__ ___ __(_) (_) /  _______ /_  __/__  ____
 / _// _ `/ // / / / / _ \/ __/ _ `// / / _ \/ __/
/___/\_, /\_,_/_/_/_/_.__/_/  \_,_//_/  \___/_/
      /_/
Equilibrator streamlines Molecular dynamics and equilibration simulations for proteins and protein-ligand complexes in a single execution
Developers: José D. D. Cediel-Becerra, Jose Cleydson F. Silva and Raquel Dias
Afiliation: Microbiology & Cell Science Deparment, University of Florida
If you find any issues, please add a new issue in our GitHub repo (https://github.com/Dias-Lab/EquilibraTor)
Version:"""+VERSION

def equilibrator_elapsed_time(
        stime: float
) -> None:
    """
    Time used to execute EquilibraTor.

    Args:
        stime (float): Start time of the process.

    Returns:
        None
    """
    etime = time.time()
    elapsed_time = etime - stime

    if elapsed_time < 60:
        time_unit = "seconds"
        ftime = round(elapsed_time, 2)
    elif elapsed_time < 3600:
        time_unit = "minutes"
        ftime = round(elapsed_time / 60, 2)
    else:
        time_unit = "hours"
        ftime = round(elapsed_time / 3600, 2)
    logging.info(f"Execution time: {ftime} {time_unit}")

stime = time.time()

class CustomFormatter(logging.Formatter):
    def __init__(self, fmt=None, datefmt=None):
        super().__init__(fmt, datefmt)
        self.counter = 0

    def format(self, record):
        self.counter += 1
        record.custom_counter = f"[{self.counter}]"
        return super().format(record)

log_format = '%(custom_counter)s - %(asctime)s - %(levelname)s - %(message)s'
formatter = CustomFormatter(log_format)
handler = logging.StreamHandler()
handler.setFormatter(formatter)
logging.basicConfig(level=logging.INFO, handlers=[handler])


def run_equilibrator_steps(pipeline_steps, args):
    first_idx = args.first_step - 1
    last_idx = args.last_step

    if not (0 <= first_idx < last_idx <= len(pipeline_steps)):
        raise ValueError("Invalid step range: check --first_step and --last_step")

    for i, (name, func) in enumerate(pipeline_steps[first_idx:last_idx], start=first_idx + 1):
        logging.info(f"{name}")
        func()

def list_equilibrator_steps(pipeline_steps):
    print("Available steps:")
    for i, (name, _) in enumerate(pipeline_steps, 1):
        print(f"{i}: {name}")

def run_command(command, cwd=None):
    #Run a shell command
    try:
        result = subprocess.run(command, shell=True, cwd=cwd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        #print(result.stdout.decode())
    except subprocess.CalledProcessError as e:
        logging.error(f"Error: {e.stderr.decode()}")
        raise

def pdb_2_mol2(ligand_file, ligand_mol2):
    """ Convert PDB to MOL for the ligand """
    command = f"obabel -ipdb -omol2 {ligand_file} -h > {ligand_mol2}"
    try:
        run_command(command)
    except Exception as e:
        logging.error(f"Failed to convert {ligand_file} to MOL2: {e}")

def generate_topology_ligand(ligand_file, ligand_name, output_dir, atom_type="gaff2", net_charge=0):
    """Generate ligand topology using ACPYPE """
    command = (
        f"acpype -i {ligand_file} -l -o gmx -b {ligand_name} "
        f"-a {atom_type} -n {net_charge}"
    )
    try:
        run_command(command, cwd=output_dir)
    except Exception as e:
        logging.error(
            f"Failed to generate topology for {ligand_file} (name: {ligand_name}): {e}"
        )

def generate_topology_protein(protein_file, topology_file, protein_gro, output_dir,
                              force_field="amber99sb", water_model="tip3p"):
    """Generate protein topology using GROMACS with robust error handling."""
    protein_file = os.path.abspath(protein_file)
    topology_file = os.path.abspath(topology_file)
    protein_gro = os.path.abspath(protein_gro)
    output_dir = os.path.abspath(output_dir)
    command = (
        f"gmx pdb2gmx -f {protein_file} -o {protein_gro} -water {water_model} "
        f"-ff {force_field} -ignh -p {topology_file}"
    )
    try:
        run_command(command, cwd=output_dir)
    except Exception as e:
        logging.error(
            f"Failed to generate topology for {protein_file}: {e}"
        )

def prepare_to_merge_topologies(topology_file, ligand_itp_list, ligand_top_list, molecule_names, output_dir, ligands_provided):
    """
    Edits topology files to prepare for merging if ligand files provided.

    Parameters:
        topology_file (str): Path to the `topol.top` file.
        ligand_itp_list (list of str): List of ligand `.itp` files.
        ligand_top_list (list of str): List of ligand `.top` files.
        molecule_names (list of str): List of molecule names (e.g., ['lig1', 'lig2']).
        ligands_provided (bool): Whether ligand files were provided.
    """
    with open(topology_file, "r") as top_file:
        topology_lines = top_file.readlines()
    
    #; Include chain topologies
    if ligands_provided:
        include_lines = [
            f'; Include ligand topology\n'
        ]
        for ligand_itp, ligand_top in zip(ligand_itp_list, ligand_top_list):
            include_lines.append(f'#include "{os.path.join(output_dir, ligand_itp)}"\n')
            include_lines.append(f'#include "{os.path.join(output_dir, ligand_top)}"\n')
        chain_includes_idx = next(
            (i for i, line in enumerate(topology_lines) 
             if line.strip() == '#include "amber99sb.ff/forcefield.itp"'),
            -1
        )
        if chain_includes_idx == -1:
            raise ValueError("Protein chain include lines not found in topol.top.")
        
        # Insert the inclusion lines if none of them already exist
        if not any(
            any(ligand_itp in line for ligand_itp in ligand_itp_list) or 
            any(ligand_top in line for ligand_top in ligand_top_list) 
            for line in topology_lines
        ):
            topology_lines = (
                topology_lines[:chain_includes_idx + 1] +
                include_lines +
                ["\n"] +
                topology_lines[chain_includes_idx + 1:]
            )

        # Add the molecule information in the [ molecules ] section for each ligand
        molecule_section_idx = next(
            (i for i, line in enumerate(topology_lines) if line.strip().startswith("[ molecules ]")),
            -1
        )
        if molecule_section_idx != -1:
            for molecule_name in molecule_names:
                molecules_entry = f"{molecule_name}         1\n"
                if molecules_entry not in topology_lines[molecule_section_idx:]:
                    topology_lines.append(molecules_entry)

    with open(topology_file, "w") as top_file:
        top_file.writelines(topology_lines)

    if ligands_provided:
        for ligand_top in ligand_top_list:
            # Modify ligand top file just like before
            with open(ligand_top, "r") as ligand_top_file:
                ligand_top_lines = ligand_top_file.readlines()

            modified_ligand_top = []
            in_defaults = False

            for line in ligand_top_lines:
                stripped_line = line.strip()

                # Ignore lines related to POSRES_LIG
                if stripped_line.startswith("#ifdef POSRES_LIG") or stripped_line.startswith("#endif") or 'posre_' in stripped_line:
                    modified_ligand_top.append(line)  
                    
                # Detect “[ defaults ]” section and comment out
                elif stripped_line.startswith("[ defaults ]"):
                    in_defaults = True
                    modified_ligand_top.append(f"; {line}")
                elif stripped_line.startswith("[ system ]"):
                    in_defaults = True
                    modified_ligand_top.append(f"; {line}")    
                elif in_defaults and stripped_line == "":
                    in_defaults = False
                elif in_defaults or stripped_line.startswith("#include") or stripped_line.startswith("[ molecules ]"):
                    modified_ligand_top.append(f"; {line}") 
                else:
                    modified_ligand_top.append(f"; {line}")

            with open(ligand_top, "w") as ligand_top_file:
                ligand_top_file.writelines(modified_ligand_top)
            
                
def merge_topologies(protein_gro, ligand_gro_list, output_gro, ligands_provided):
    """Merge protein and ligand topologies."""
    
    # Read protein gro
    with open(protein_gro, 'r') as f1:
        protein_lines = f1.readlines()

    total_atoms = int(protein_lines[1])
    merged_body_lines = protein_lines[2:-1]

    # Read and append ligand gro files
    if ligands_provided:
        for ligand_gro in ligand_gro_list:
            with open(ligand_gro, 'r') as lig_f:
                ligand_lines = lig_f.readlines()
                total_atoms += int(ligand_lines[1])
                merged_body_lines.extend(ligand_lines[2:-1])

    with open(output_gro, 'w') as out:
        out.write(protein_lines[0])  # title line
        out.write(f"{total_atoms}\n")
        out.writelines(merged_body_lines)
        out.write(protein_lines[-1])  # box vectors line

def make_copy_of_protein(input_gro, output_gro):
    """Make copy of protein"""
    command = f"gmx editconf -f {input_gro} -o {output_gro}"
    try:
        run_command(command)
    except Exception as e:
        logging.error(f"Failed to copy protein from {input_gro} to {output_gro}: {e}")

def create_simulation_box(input_gro, output_gro, box_type="cubic", distance=1.2):
    """Create a simulation box using GROMACS editconf with error handling."""
    command = f"gmx editconf -f {input_gro} -o {output_gro} -c -d {distance} -bt {box_type}"
    try:
        run_command(command)
    except Exception as e:
        logging.error(f"Failed to create simulation box for {input_gro}: {e}")

def solvate_system(input_gro, output_gro, topology_file, water_model="tip3p"):
    """Add water to the system using appropriate solvent configuration with error handling."""
    water_config_map = {
        "spc": "spc216.gro",
        "spce": "spc216.gro",
        "tip3p": "spc216.gro",
        "tip4p": "tip4p.gro",
        "tip5p": "tip4p.gro"
    }
    solvent_config = water_config_map.get(water_model.lower(), "spc216.gro")

    if water_model.lower() == "tip5p":
        logging.warning("TIP5P configuration file not standard in GROMACS.")
        logging.warning("Using tip4p.gro coordinates. Geometry will adjust during equilibration.")

    command = f"gmx solvate -cp {input_gro} -cs {solvent_config} -o {output_gro} -p {topology_file}"

    try:
        run_command(command)
    except Exception as e:
        logging.error(f"Failed to solvate system {input_gro} with {water_model}: {e}")

def combine_and_insert_unique_atomtypes(ligand_itp_list, topology_file):
    all_atomtypes = []
    for ligand_itp in ligand_itp_list:
        with open(ligand_itp, 'r') as f:
            lines = f.readlines()

        atomtypes_section = []
        in_atomtypes = False
        for line in lines:
            if line.strip().startswith("[ atomtypes ]"):
                in_atomtypes = True
            elif line.strip().startswith("[") and in_atomtypes:
                break
            if in_atomtypes:
                atomtypes_section.append(line)

        # Comment out the atomtypes section in ligand .itp
        modified_lines = [
            f"; {line}" if line.strip() and line in atomtypes_section else line for line in lines
        ]
        with open(ligand_itp, 'w') as f:
            f.writelines(modified_lines)

        all_atomtypes.extend(atomtypes_section)

    # Remove duplicated lines while preserving order
    seen = set()
    unique_atomtypes = []
    for line in all_atomtypes:
        if line not in seen:
            seen.add(line)
            unique_atomtypes.append(line)

    # Insert combined unique atomtypes section once into topol.top
    with open(topology_file, 'r') as f:
        topo_lines = f.readlines()

    ff_index = next((i for i, l in enumerate(topo_lines) if "forcefield.itp" in l), -1)
    if ff_index == -1:
        raise ValueError("forcefield.itp not found in topology")

    updated_topology = (
        topo_lines[:ff_index+1] + ["\n"] + unique_atomtypes + ["\n"] + topo_lines[ff_index+1:]
    )
    with open(topology_file, 'w') as f:
        f.writelines(updated_topology)

def add_ions(mdp_file, input_gro, output_gro, topology_file, ions_tpr, output_dir, pos_ion="NA", neg_ion="CL"):
    """Add user-specified ions to the system with robust error handling and logging."""
    grompp = f"gmx grompp -f {mdp_file} -c {input_gro} -p {topology_file} -o {ions_tpr}"
    genion = f"echo SOL | gmx genion -s {ions_tpr} -o {output_gro} -p {topology_file} -pname {pos_ion} -nname {neg_ion} -neutral"

    try:
        run_command(grompp, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed to run grompp for ions preparation: {e}")
        raise

    try:
        run_command(genion, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed to run genion to add ions: {e}")
        raise

def minimize_energy(mdp_file, input_gro, output_gro, topology_file, em_tpr, em_edr, potential_xvg, output_dir):
    """Perform energy minimization with robust error handling."""
    grompp_cmd = f"gmx grompp -f {mdp_file} -c {input_gro} -p {topology_file} -o {em_tpr}"
    mdrun_cmd = f"gmx mdrun -v -deffnm {em_tpr.replace('.tpr', '')}"
    energy_cmd = f"echo '13 0' | gmx energy -f {em_edr} -o {potential_xvg}"

    try:
        run_command(grompp_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed grompp step during energy minimization: {e}")
        raise

    try:
        run_command(mdrun_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed mdrun step during energy minimization: {e}")
        raise

    try:
        run_command(energy_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed energy extraction step during energy minimization: {e}")
        raise

def plot_energy_results(xvg_file, output_pdf):
    """Generate plots from .xvg files with error handling."""
    try:
        data = np.loadtxt(xvg_file, comments=['@', '#'])
    except Exception as e:
        logging.error(f"Failed to load data from {xvg_file}: {e}")
        return

    try:
        plt.figure()
        plt.plot(data[:, 0], data[:, 1])
        plt.xlabel('Time (ps)')
        plt.ylabel('Potential Energy (kJ/mol)')
        plt.title('Potential Energy vs Time')
        plt.savefig(output_pdf)
        plt.close()
    except Exception as e:
        logging.error(f"Failed to plot and save energy results to {output_pdf}: {e}")

def get_potential_backbone_pressure_xvgs(em_edr, em_tpr, potential_xvg, rmsf_xvg, pressure_xvg, em_trr):
    """Extract potential energy, backbone RMSF, and pressure data to XVG files with error handling."""
    cmd_potential = f"echo 'Potential' | gmx energy -f {em_edr} -o {potential_xvg}"
    cmd_rmsf = f"echo 'Backbone' | gmx rmsf -s {em_tpr} -f {em_trr} -o {rmsf_xvg}"
    cmd_pressure = f"echo 'Pressure' | gmx energy -f {em_edr} -o {pressure_xvg}"

    try:
        run_command(cmd_potential)
    except Exception as e:
        logging.error(f"Failed to extract potential energy to {potential_xvg}: {e}")
        raise

    try:
        run_command(cmd_rmsf)
    except Exception as e:
        logging.error(f"Failed to extract backbone RMSF to {rmsf_xvg}: {e}")
        raise

    try:
        run_command(cmd_pressure)
    except Exception as e:
        logging.error(f"Failed to extract pressure to {pressure_xvg}: {e}")
        raise

def plot_em_results(potential_xvg, pressure_xvg, rmsf_xvg, energy_minimization_results):
    """Generate combined energy minimization result plots with error handling."""
    try:
        potential = np.loadtxt(potential_xvg, comments=['#', '@'])
    except Exception as e:
        logging.error(f"Failed to load potential energy data from {potential_xvg}: {e}")
        return

    try:
        pressure = np.loadtxt(pressure_xvg, comments=['#', '@'])
    except Exception as e:
        logging.error(f"Failed to load pressure data from {pressure_xvg}: {e}")
        return

    try:
        rmsf = np.loadtxt(rmsf_xvg, comments=['#', '@'])
    except Exception as e:
        logging.error(f"Failed to load RMSF data from {rmsf_xvg}: {e}")
        return

    try:
        fig, axs = plt.subplots(1, 3, figsize=(20, 6), sharex=False)

        axs[0].plot(potential[:, 0], potential[:, 1])
        axs[0].set_ylabel('Potential Energy\n(kJ/mol)')
        axs[0].set_xlabel('Time (ps)')

        axs[1].plot(pressure[:, 0], pressure[:, 1])
        axs[1].set_ylabel('Pressure (bar)')
        axs[1].set_xlabel('Time (ps)')

        axs[2].plot(rmsf[:, 0], rmsf[:, 1])
        axs[2].set_ylabel('RMSF (nm)')
        axs[2].set_xlabel('Atom')

        plt.tight_layout()
        plt.savefig(energy_minimization_results, format='pdf', dpi=600)
        plt.close()
    except Exception as e:
        logging.error(f"Failed to plot or save energy minimization results to {energy_minimization_results}: {e}")

def get_final_minimized_structure(em_tpr, em_trr, final_minimized):
    """Extract final minimized structure with error handling."""
    command = f"echo 'non-Water' | gmx trjconv -s {em_tpr} -f {em_trr} -o {final_minimized} -pbc nojump"
    try:
        run_command(command)
    except Exception as e:
        logging.error(f"Failed to extract final minimized structure to {final_minimized}: {e}")

def load_xvg(filename):
    """Load numerical data from an XVG file, ignoring comment lines starting with @ or #."""
    try:
        data = np.loadtxt(filename, comments=['#', '@'])
        return data
    except Exception as e:
        logging.error(f"Failed to load XVG file {filename}: {e}")
        return None

def plot_eq(eq_potential, eq_pressure_xvg, eq_temperature_xvg, eq_rmsd_xvg, eq_rmsf_xvg, eq_gyrate_xvg, equilibration_analysis):
    """Generate a 3x2 panel plot of equilibration analysis with error handling."""
    potential = load_xvg(eq_potential)
    pressure = load_xvg(eq_pressure_xvg)
    temperature = load_xvg(eq_temperature_xvg)
    rmsd = load_xvg(eq_rmsd_xvg)
    rmsf = load_xvg(eq_rmsf_xvg)
    gyrate = load_xvg(eq_gyrate_xvg)

    # Check all data loaded correctly before plotting
    data_list = [potential, pressure, temperature, rmsd, rmsf, gyrate]
    if any(d is None for d in data_list):
        logging.error("One or more XVG files could not be loaded, skipping plotting.")
        return

    try:
        fig, axs = plt.subplots(3, 2, figsize=(12, 15))

        axs[0, 0].plot(potential[:, 0], potential[:, 1], label='Potential Energy', color='b')
        axs[0, 0].set_ylabel('Energy (kJ/mol)')
        axs[0, 0].set_xlabel('Time (ps)')
        axs[0, 0].legend()

        axs[0, 1].plot(pressure[:, 0], pressure[:, 1], label='Pressure', color='g')
        axs[0, 1].set_ylabel('Pressure (bar)')
        axs[0, 1].set_xlabel('Time (ps)')
        axs[0, 1].legend()

        axs[1, 0].plot(temperature[:, 0], temperature[:, 1], label='Temperature', color='r')
        axs[1, 0].set_ylabel('Temperature (K)')
        axs[1, 0].set_xlabel('Time (ps)')
        axs[1, 0].legend()

        axs[1, 1].plot(rmsd[:, 0], rmsd[:, 1], label='RMSD', color='c')
        axs[1, 1].set_ylabel('RMSD (nm)')
        axs[1, 1].set_xlabel('Time (ps)')
        axs[1, 1].legend()

        axs[2, 0].plot(rmsf[:, 0], rmsf[:, 1], label='RMSF', color='m')
        axs[2, 0].set_ylabel('RMSF (nm)')
        axs[2, 0].set_xlabel('Atom')
        axs[2, 0].legend()

        axs[2, 1].plot(gyrate[:, 0], gyrate[:, 1], label='Radius of Gyration', color='y')
        axs[2, 1].set_ylabel('Rg (nm)')
        axs[2, 1].set_xlabel('Time (ps)')
        axs[2, 1].legend()

        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.savefig(equilibration_analysis, format='pdf', dpi=600)
        plt.close()
    except Exception as e:
        logging.error(f"Failed to generate equilibration plots saved at {equilibration_analysis}: {e}")

def get_last_frame_time(trr_file):
    """Extract the time of the last frame from the trajectory using `gmx check`."""
    result = subprocess.run(
        ["gmx", "check", "-f", trr_file],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        input="\n"
    )
    matches = re.findall(r"Reading frame\s+\d+\s+time\s+([\d.]+)", result.stdout)

    if matches:
        return float(matches[-1])  # Last one is the final frame
    else:
        raise RuntimeError("Could not determine last frame time from trajectory.")

def extract_last_frame_and_unwrap(equilibration_tpr, equilibration_trr,
                                  final_last_equilibrated_pdb, final_equilibrated_gro, final_equilibrated_pdb,
                                  group1="non-Water", group2="System"):
    """Extract the last frame and produce nojump trajectories, robustly."""
    last_frame_time = get_last_frame_time(equilibration_trr)

    get_last_frame = (
        f"echo '{group1}' | gmx trjconv -s {equilibration_tpr} -f {equilibration_trr} "
        f"-o {final_last_equilibrated_pdb} -dump {last_frame_time}"
    )

    get_movie_pdb = (
        f"echo '{group1}' | gmx trjconv -s {equilibration_tpr} -f {equilibration_trr} "
        f"-o {final_equilibrated_pdb} -pbc nojump"
    )

    get_movie_gro = (
        f"echo '{group2}' | gmx trjconv -s {equilibration_tpr} -f {equilibration_trr} "
        f"-o {final_equilibrated_gro} -pbc nojump"
    )

    try:
        run_command(get_last_frame)
    except Exception as e:
        logging.error(f"Failed to extract last frame to {final_last_equilibrated_pdb}: {e}")
        raise

    try:
        run_command(get_movie_pdb)
    except Exception as e:
        logging.error(f"Failed to generate nojump PDB trajectory to {final_equilibrated_pdb}: {e}")
        raise

    try:
        run_command(get_movie_gro)
    except Exception as e:
        logging.error(f"Failed to generate nojump GRO trajectory to {final_equilibrated_gro}: {e}")
        raise

def run_NVT_equilibration(topology_file, equilibration_tpr, em_gro, output_dir):
    """Run NVT equilibration with robust error handling."""
    grompp_cmd = f"gmx grompp -f {NVT_MDP} -c {em_gro} -p {topology_file} -o {equilibration_tpr}"
    mdrun_cmd = f"gmx mdrun -s {equilibration_tpr} -deffnm {equilibration_tpr.replace('.tpr','')}"

    try:
        run_command(grompp_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed to run grompp for NVT equilibration: {e}")
        raise

    try:
        run_command(mdrun_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed to run mdrun for NVT equilibration: {e}")
        raise

def get_equilibration_output(equilibration_edr, eq_potential_xvg, eq_pressure_xvg, eq_temperature_xvg,
                             equilibration_tpr, equilibration_trr, eq_rmsd_xvg, eq_rmsf_xvg, eq_gyrate_xvg,
                             final_last_equilibrated_pdb, final_equilibrated_pdb, equilibration_analysis, final_equilibrated_gro):
    commands = [
        (f"echo 'Potential' | gmx energy -f {equilibration_edr} -o {eq_potential_xvg}", "Extract potential energy"),
        (f"echo 'Pressure' | gmx energy -f {equilibration_edr} -o {eq_pressure_xvg}", "Extract pressure"),
        (f"echo 'Temperature' | gmx energy -f {equilibration_edr} -o {eq_temperature_xvg}", "Extract temperature"),
        (f"echo 'Backbone Backbone' | gmx rms -s {equilibration_tpr} -f {equilibration_trr} -o {eq_rmsd_xvg}", "Calculate RMSD"),
        (f"echo 'Backbone' | gmx rmsf -s {equilibration_tpr} -f {equilibration_trr} -o {eq_rmsf_xvg}", "Calculate RMSF"),
        (f"echo 'Protein' | gmx gyrate -s {equilibration_tpr} -f {equilibration_trr} -o {eq_gyrate_xvg}", "Calculate radius of gyration")
    ]

    for cmd, description in commands:
        try:
            run_command(cmd)
        except Exception as e:
            logging.error(f"Failed to {description}: {e}")
            raise

    try:
        extract_last_frame_and_unwrap(equilibration_tpr, equilibration_trr,
                                     final_last_equilibrated_pdb, final_equilibrated_gro, final_equilibrated_pdb)
    except Exception as e:
        logging.error(f"Failed in extract_last_frame_and_unwrap: {e}")
        raise

    try:
        plot_eq(eq_potential_xvg, eq_pressure_xvg, eq_temperature_xvg, eq_rmsd_xvg, eq_rmsf_xvg, eq_gyrate_xvg, equilibration_analysis)
    except Exception as e:
        logging.error(f"Failed to plot equilibration analysis: {e}")
        raise

def run_NPT_equilibration(topology_file, npt_tpr, nvt_gro, final_last_npt_pdb, output_dir):
    """Run NPT equilibration with robust error handling."""
    grompp_cmd = f"gmx grompp -f {NPT_MDP} -c {nvt_gro} -p {topology_file} -o {npt_tpr}"
    mdrun_cmd = f"gmx mdrun -s {npt_tpr} -deffnm {npt_tpr.replace('.tpr','')}"

    try:
        run_command(grompp_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed to run grompp for NPT equilibration: {e}")
        raise

    try:
        run_command(mdrun_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed to run mdrun for NPT equilibration: {e}")
        raise


def run_production_stage(topology_file, production_tpr, npt_gro, output_dir):
    """Run production MD stage with robust error handling."""
    grompp_cmd = f"gmx grompp -f {PRODUCTION_MDP} -c {npt_gro} -p {topology_file} -o {production_tpr}"
    mdrun_cmd = f"gmx mdrun -s {production_tpr} -deffnm {production_tpr.replace('.tpr','')}"

    try:
        run_command(grompp_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed to run grompp for production stage: {e}")
        raise

    try:
        run_command(mdrun_cmd, cwd=output_dir)
    except Exception as e:
        logging.error(f"Failed to run mdrun for production stage: {e}")
        raise
    
# Workflow execution
def main():
    parser = argparse.ArgumentParser(
        description=DESCRIPTION, formatter_class=argparse.RawTextHelpFormatter
    )
    
    input_group = parser.add_argument_group("Input options")
    input_group.add_argument(
        "-l", "--ligands", 
        required=False,
        nargs='+',
        type=str, 
        help="Path(s) to the ligand file(s)."
    )
    input_group.add_argument(
        "-p", "--protein", 
        required=True, 
        type=str, 
        help="Path to the protein file."
    )

    acpype_group = parser.add_argument_group("Specify options for ligand topology generation with acpype")
    acpype_group.add_argument(
	"-aa", "--atom_type",
	required=False,
	type=str,
	choices=["gaff", "amber", "gaff2", "amber2"],
	default="gaff2",
	help="Specify the atom type supported by acpype: gaff, amber, gaff2 (default), amber2"
    )
    acpype_group.add_argument(
	"-an", "--net_charge",
	required=False,
	type=int,
	default=0,
	help="net molecular charge (int), default is -an=0"
    )
    
    gromacs_topology_group = parser.add_argument_group("Specify options for protein topology generation with gromacs")
    gromacs_topology_group.add_argument(
	"-gff", "--force_field",
	required=False,
	type=str,
	choices=["amber94", "amber96", "amber99", "amber99sb", "amber99sb-ildn", "amber03", "ambergs"],
	default="amber99sb",
	help="Specify the Force Fields supported by GROMACS: amber94, amber96, amber99, amber99sb (default), amber99sb-ildn, amber03, ambergs"
    )
    gromacs_topology_group.add_argument(
	"-gwm", "--water_model",
	required=False,
	type=str,
	choices=["spc", "spce", "tip3p", "tip4p", "tip5p"],
	default="tip3p",
	help="Specify the water model: spc, spce, tip3p (default), tip4p, tip5p"
    )

    gromacs_box_group = parser.add_argument_group("Specify options for box generation with gromacs")
    gromacs_box_group.add_argument(
        "-gbt", "--box_type",
        required=False,
        type=str,
	choices=["triclinic", "cubic", "dodecahedron", "octahedron"],
        default="cubic",
        help="Specify the box type supported by GROMACS: triclinic, cubic (default), dodecahedron, octahedron"
    )
    gromacs_box_group.add_argument(
	"-gd", "--distance",
        required=False,
        type=int,
        default=1.2,
        help="Specify the distance between the solute and the box, default is -gd 1.2"
    )

    gromacs_ions_group = parser.add_argument_group("Specify monoatomic cation/anion supported by the force field")
    gromacs_ions_group.add_argument(
        "-gpi", "--pos_ion",
        required=False,
	type=str,
	choices=["NA", "K", "MG"],
        default="NA",
        help="Specify the monoatomic cation supported by the force field: NA (default), K, MG, etc"
    )
    gromacs_ions_group.add_argument(
	"-gni", "--neg_ion",
        required=False,
        type=str,
	choices=["CL", "F", "BR"],
        default="CL",
        help="Specify the monoatomic anion supported by the force field: CL (default), F, BR, etc"
    )

    steps_group = parser.add_argument_group("Specify the steps for the execution")
    steps_group.add_argument(
        "-fs", "--first_step",
        required=False,
        type=int,
        default=1,
        help="Step number to start Equilibratior from (1-based)"
    )
    steps_group.add_argument(
        "-ls", "--last_step",
        required=False,
        type=int,
        help="Step number to end at (1-based)"
    )
    steps_group.add_argument(
        "-as", "--all_steps",
        required=False,
        action="store_true",
        help="List of Equilibrator steps and exit"
    )

    
    # Parse arguments
    args = parser.parse_args()

    # print EquilibraTor logo
    print(DESCRIPTION)
    
    # defining variable for input files 
    ligand_files = args.ligands if args.ligands else []
    
    protein_file = args.protein
    protein_name = os.path.splitext(os.path.basename(protein_file))[0]
    ligand_names = [os.path.splitext(os.path.basename(lig))[0] for lig in ligand_files]
    Project_dir = f"{protein_name}_{'_'.join(ligand_names)}" if ligand_files else protein_name
    
    # Creating the directory to store outputs
    output_dir = os.path.join(os.getcwd(), Project_dir)
    os.makedirs(output_dir, exist_ok=True)    
    protein_gro = os.path.join(output_dir, f"{protein_name}_processed.gro")
    protein_gro_complex = protein_gro.replace('.gro','_complex.gro')
    merged_gro = os.path.join(output_dir, "merged.gro")

    #protein_or_merged_gro = merged_gro if ligand_file else protein_gro        
    protein_or_merged_gro = merged_gro if ligand_files else protein_gro
    
    box_gro = os.path.join(output_dir, "box.gro")
    solvated_gro = os.path.join(output_dir, "solvated.gro")
    topology_file = os.path.join(output_dir, "topol.top")
    minimized_gro = os.path.join(output_dir, "minimized.gro")
    energy_plot = os.path.join(output_dir, f"{Project_dir}_potential.pdf")
    ions_tpr = os.path.join(output_dir, "ions.tpr")   

    # Prepare ligand related paths as lists
    ligand_mol2_list = []
    for ligand_file, ligand_name in zip(ligand_files, ligand_names):
        ligand_mol2 = os.path.join(output_dir, f"{ligand_name}.mol2")
        ligand_mol2_list.append(ligand_mol2)
        
    ligand_itp_list = []
    ligand_top_list = []
    ligand_acpype_gro_list = []
    atomtypes_file_list = []
    for ligand_name in ligand_names:
        acpype_dir = os.path.join(output_dir, f"{ligand_name}.acpype")
        ligand_itp_list.append(os.path.join(acpype_dir, f"{ligand_name}_GMX.itp"))
        ligand_top_list.append(os.path.join(acpype_dir, f"{ligand_name}_GMX.top"))
        ligand_acpype_gro_list.append(os.path.join(acpype_dir, f"{ligand_name}_GMX.gro"))
        atomtypes_file_list.append(os.path.join(acpype_dir, "atomtypes.atp"))
    
    # Minimization workflow
    em_tpr = os.path.join(output_dir, "em.tpr")
    em_edr = os.path.join(output_dir, "em.edr")
    em_trr = os.path.join(output_dir, "em.trr")
    pressure_xvg = os.path.join(output_dir, "pressure.xvg")
    potential_xvg = os.path.join(output_dir, "potential.xvg")
    rmsf_xvg = os.path.join(output_dir, "rmsf.xvg")
    solv_ions = os.path.join(output_dir, "solv_ions.gro")
    em_gro = os.path.join(output_dir, "em.gro")
    final_minimized = os.path.join(output_dir, "final_minimized.pdb")

    # Equilibration workflow
    equilibration_tpr = os.path.join(output_dir, "equilibration.tpr")
    equilibration_edr = os.path.join(output_dir, "equilibration.edr")
    equilibration_trr = os.path.join(output_dir, "equilibration.trr")
    eq_potential_xvg = os.path.join(output_dir, "eq_potential.xvg")
    eq_pressure_xvg = os.path.join(output_dir, "eq_pressure.xvg")
    eq_temperature_xvg = os.path.join(output_dir, "eq_temperature.xvg")
    eq_rmsd_xvg = os.path.join(output_dir, "eq_rmsd.xvg")
    eq_rmsf_xvg = os.path.join(output_dir, "eq_rmsf.xvg")
    eq_gyrate_xvg = os.path.join(output_dir, "eq_gyrate.xvg")
    final_equilibrated_pdb = os.path.join(output_dir, "final_minimized_equilibrated.pdb")
    final_last_equilibrated_pdb = os.path.join(output_dir, "final_minimized_equilibrated_last.pdb")
    energy_minimization_results = os.path.join(output_dir, f"{Project_dir}_energy_minimization_results.pdf")
    equilibration_analysis = os.path.join(output_dir, f"{Project_dir}_equilibration_analysis.pdf")
    final_equilibrated_gro = os.path.join(output_dir, "final_minimized_equilibrated.gro")

    # NPT Equilibration workflow
    npt_tpr = os.path.join(output_dir, "npt_equilibration.tpr")
    npt_edr = os.path.join(output_dir, "npt_equilibration.edr")
    npt_trr = os.path.join(output_dir, "npt_equilibration.trr")
    npt_potential_xvg = os.path.join(output_dir, "npt_potential.xvg")
    npt_pressure_xvg = os.path.join(output_dir, "npt_pressure.xvg")
    npt_temperature_xvg = os.path.join(output_dir, "npt_temperature.xvg")
    npt_rmsd_xvg = os.path.join(output_dir, "npt_rmsd.xvg")
    npt_rmsf_xvg = os.path.join(output_dir, "npt_rmsf.xvg")
    npt_gyrate_xvg = os.path.join(output_dir, "npt_gyrate.xvg")
    final_npt_pdb = os.path.join(output_dir, "final_npt_equilibrated.pdb")
    final_npt_gro = os.path.join(output_dir, "final_npt_equilibrated.gro")
    final_last_npt_pdb = os.path.join(output_dir, "final_npt_equilibrated_last.pdb")
    npt_analysis_pdf = os.path.join(output_dir, f"{Project_dir}_npt_equilibration_analysis.pdf")

    # Production workflow
    production_tpr = os.path.join(output_dir, "production_stage.tpr")
    production_edr = os.path.join(output_dir, "production_stage.edr")
    production_trr = os.path.join(output_dir, "production_stage.trr")
    production_potential_xvg = os.path.join(output_dir, "production_potential.xvg")
    production_pressure_xvg = os.path.join(output_dir, "production_pressure.xvg")
    production_temperature_xvg = os.path.join(output_dir, "production_temperature.xvg")
    production_rmsd_xvg = os.path.join(output_dir, "production_rmsd.xvg")
    production_rmsf_xvg = os.path.join(output_dir, "production_rmsf.xvg")
    production_gyrate_xvg = os.path.join(output_dir, "production_gyrate.xvg")
    final_production_pdb = os.path.join(output_dir, "final_production.pdb")
    final_production_gro = os.path.join(output_dir, "final_production.gro")
    final_last_production_pdb = os.path.join(output_dir, "final_production_last.pdb")
    production_analysis_pdf = os.path.join(output_dir, f"{Project_dir}_production_analysis.pdf")

    equilibrator_steps = []
    # === Protein Topology ===
    equilibrator_steps.append((f"Generating topology for the protein: {protein_name}", lambda: generate_topology_protein(protein_file, topology_file, protein_gro, output_dir, force_field=args.force_field, water_model=args.water_model)))

    # === Ligand Prep ===
    for ligand_file, ligand_mol2, ligand_name in zip(ligand_files, ligand_mol2_list, ligand_names):	
    	equilibrator_steps.append((f"Converting {ligand_name} PDB to MOL2", lambda lf=ligand_file, lm=ligand_mol2: pdb_2_mol2(lf, lm)))
    	equilibrator_steps.append((f"Generating topology for the ligand: {ligand_name}", lambda lm=ligand_mol2, ln=ligand_name: generate_topology_ligand(lm, ln, output_dir, atom_type=args.atom_type, net_charge=args.net_charge)))
    #sys.exit()

    # === Merge Prep ===
    equilibrator_steps.append(("Checking wether merging topology file(s) is necessary", lambda: prepare_to_merge_topologies(topology_file, ligand_itp_list, ligand_top_list, ligand_names, output_dir, bool(ligand_files))))
    
    if ligand_files:
        equilibrator_steps.append((f"Making a copy of the protein: {protein_file}", lambda: make_copy_of_protein(protein_gro, protein_gro_complex)))
        equilibrator_steps.append(("Merging topologies", lambda: merge_topologies(protein_gro_complex, ligand_acpype_gro_list, merged_gro, True)))

    ## Modify ligand itp(s) to comment [ atomtypes ] and update main topology before ion addition and minimization
    equilibrator_steps.append(("Combining and inserting unique atomtypes into main topology", lambda: combine_and_insert_unique_atomtypes(ligand_itp_list, topology_file)))
     
    # Simulation setup
    # === Simulation Setup ===
    equilibrator_steps.append(("Creating the simulation box", lambda: create_simulation_box(protein_or_merged_gro, box_gro, box_type=args.box_type, distance=args.distance)))
    equilibrator_steps.append(("Solvating the system", lambda: solvate_system(box_gro, solvated_gro, topology_file, water_model=args.water_model)))
    equilibrator_steps.append(("Adding ions to neutralize the system", lambda: add_ions(IONS_MDP, solvated_gro, solv_ions, topology_file, ions_tpr, output_dir, pos_ion=args.pos_ion, neg_ion=args.neg_ion)))
    
    # === Energy Minimization ===
    equilibrator_steps.append(("Running energy minimization", lambda: minimize_energy(MINIM_MDP, solv_ions, minimized_gro, topology_file, em_tpr, em_edr, potential_xvg, output_dir)))
    equilibrator_steps.append(("Plotting potential energy", lambda: plot_energy_results(potential_xvg, energy_plot)))
    equilibrator_steps.append(("Obtaining potential, backbone, and pressure xvgs", lambda: get_potential_backbone_pressure_xvgs(em_edr, em_tpr, potential_xvg, rmsf_xvg, pressure_xvg, em_trr)))
    equilibrator_steps.append(("Plotting panel of additional energy minimization results", lambda: plot_em_results(potential_xvg, pressure_xvg, rmsf_xvg, energy_minimization_results)))
    equilibrator_steps.append(("Getting final minimized pdb structure", lambda: get_final_minimized_structure(em_tpr, em_trr, final_minimized)))

    # === NVT Equilibration ===
    equilibrator_steps.append(("Running NVT equilibration", lambda: run_NVT_equilibration(topology_file, equilibration_tpr, em_gro, output_dir
    )))
    equilibrator_steps.append(("Getting NVT equilibration output", lambda: get_equilibration_output(equilibration_edr, eq_potential_xvg, eq_pressure_xvg, eq_temperature_xvg, equilibration_tpr, equilibration_trr, eq_rmsd_xvg, eq_rmsf_xvg, eq_gyrate_xvg, final_last_equilibrated_pdb, final_equilibrated_pdb, equilibration_analysis, final_equilibrated_gro
    )))

    #===NPT Equilibration ===
    equilibrator_steps.append(("Running NPT equilibration", lambda: run_NPT_equilibration(topology_file, npt_tpr, final_equilibrated_gro, final_last_npt_pdb, output_dir
    )))
    equilibrator_steps.append(("Getting NPT equilibration output", lambda: get_equilibration_output(npt_edr, npt_potential_xvg, npt_pressure_xvg, npt_temperature_xvg, npt_tpr, npt_trr, npt_rmsd_xvg, npt_rmsf_xvg, npt_gyrate_xvg, final_last_npt_pdb, final_npt_pdb, npt_analysis_pdf, final_npt_gro
    )))

    #===Production stage ==
    equilibrator_steps.append(("Running Production stage", lambda: run_production_stage(topology_file, production_tpr, final_npt_gro, output_dir
    )))
    
    equilibrator_steps.append(("Getting Production output", lambda: get_equilibration_output(production_edr, production_potential_xvg, production_pressure_xvg, production_temperature_xvg, production_tpr, production_trr, production_rmsd_xvg, production_rmsf_xvg, production_gyrate_xvg, final_last_production_pdb, final_production_pdb, production_analysis_pdf, final_production_gro
    )))

    if args.last_step is None:
        args.last_step = len(equilibrator_steps)
    if args.all_steps:
        list_equilibrator_steps(equilibrator_steps)
        return
    run_equilibrator_steps(equilibrator_steps, args)

    equilibrator_elapsed_time(stime)
    
if __name__ == "__main__":
    main()
